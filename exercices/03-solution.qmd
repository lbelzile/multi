---
title: "Sélection de variables"
execute:
  echo: true
  eval: true
  message: false
  warning: false
  error: false
---

## Exercice 3.1


1. *Faites une analyse exploratoire des variables explicatives*: 
   - *Quelles variables devraient êtres exclues de la modélisation? Justifiez votre réponse.*
   - *Comparez la variable réponse avec les autres variables: y a-t-il des transformations qui améliorerait l'ensemble de variables candidates: interactions, création de variables dychotomiques, transformations (racines carrée, transformation logarithmique, etc.)?*
   - *Vérifiez s'il y a des variables catégorielles encodées comme des variables numériques.*
   
On remarque avec l'aide `?college` que le nombre d'applications, `napplications`, le nombre d'admissions parmi ces applications `nadmission` et le nombre d'offres converties par les candidat.e.s, `ninscrits`, sont reliées et ne peuvent être employées.

Plusieurs variables seront fortement corrélées parce qu'elles dépendent de la capacité d'accueil de l'établissement d'enseignement. Ainsi, on pourrait créer une variable qui représente le pourcentage de temps partiels pour les premiers cycles (plutôt que le décompte). Les variables `pourcentdoctorat` et `pourcentterminal`, sont fortement corrélées puisque la plupart des diplômes terminaux (incluant les titres professionnels, les doctorats de premier cycle en médecine, etc.) sont des PhD: le modèle choisira la variable la plus adéquate. Il n'y a pas de variables catégorielles hors variables binaires. Côté vérifications d'usage, on note que `tauxdiplom` et `pourcentdoctorat` sont supérieurs à 100%.
   
On devra retirer la variable catégorielle `nom`, qui a une modalité différente pour chaque observation.   
   
```{r}
library(dplyr)
data(college, package = "hecmulti")
str(college)
summary(college)
summary(college)
with(college, cor(pourcentdoctorat, pourcentterminal))
db <- college |>
  mutate(
    tauxdiplom = pmin(tauxdiplom, 100),
    pourcentdoctorat = pmin(pourcentdoctorat, 100),
    pctpart1c = tempspart1c/(tempsplein1c+tempspart1c)) |>
  select(! c(nom, 
             tempsplein1c, 
             tempspart1c, 
             nadmission, 
             ninscrits))
```

On peut désormais considérer une séparation en tiers.
Pour ce faire, je vais échantillonner des variables logiques vrais et faux avec une cote de 2 pour 1 et ensuite sélectionner les lignes qui correspondent.

```{r}
set.seed(60602)
test <- sample(x = c(FALSE, TRUE),
               size = nrow(db),
               replace = TRUE, 
               prob = c(1/3, 2/3))
db_a <- db[test,]
db_v <- db[!test,]
```

Pour l'estimation, on pourrait simplement calculer 



```{r}
formule <- formula(napplications ~ .^2)

leaps::regsubsets(
  x = formule, 
  data = db_a,
  method = "seqrep")
```

# 
leaps::regsubsets()
```
   
   
2. Scindez la base de données en échantillon avec données d'entraînement (environ 2/3 des données) et échantillon de validation; utilisez le germe aléatoire `60602` via `set.seed(60602)`. 
   - Sélectionnez un modèle à l'aide d'une des méthodes couvertes, mais en basant votre choix sur l'erreur moyenne quadratique évaluée sur l'échantillon de validation.
3. Répétez la sélection, cette fois en prenant comme critère pour l'erreur moyenne quadratique évaluée par validation croisée (aléatoire) à cinq plis.
4. Créez un tableau avec le nombre de coefficients de votre modèle final et un estimé de l'erreur moyenne quadratique obtenu par validation externe ou croisée. 
5. Commentez sur le meilleur modèle parmi les combinaisons.
